#!/usr/bin/env bash

set -Eeuo pipefail
export PATH=${SSH_BASHLIB_LIBRARY_PATH}:$PATH
# shellcheck source=../../bash-lib/lib/bashlib-error.sh
source "bashlib-error.sh"
error::set_trap
# shellcheck source=../../bash-lib/lib/bashlib-echo.sh
source "bashlib-echo.sh"
# shellcheck source=ssh-x-lib.sh
source ssh-x-lib.sh
# shellcheck source=../../bash-lib/lib/bashlib-command.sh
source "bashlib-command.sh"
# shellcheck source=../../bash-lib/lib/bashlib-doc.sh
source "bashlib-doc.sh"
# shellcheck source=../../bash-lib/lib/bashlib-crypto.sh
source "bashlib-crypto.sh"
# shellcheck source=../../bash-lib/lib/bashlib-array.sh
source "bashlib-array.sh"


synopsis_comment(){

  cat << 'EOF'

Usage:

```bash
ssh-x key comment path "New comment"
```

where:

* `path`         - The path to the key
* `New Comment`  - A new comment
EOF

}

comment_command(){
  # Change the comment
  if [ $# -ne 2 ]; then
     synopsis_comment
     echo::err "A key path and a comment is mandatory"
     error::exit 1
  fi
  FILE=${1}
  if [ ! -f "$FILE" ]; then
    echo::err "The key file ($FILE) does not exist"
    error::exit 1
  fi
  ssh-keygen -c -f "$FILE" -C "$2"
}

# The synopsis function is required by the doc::usage
synopsis(){

  cat << 'EOF'
```bash
ssh-x key command options
```

where `command` can be:

* `add`          - Add a private key from the agent. This is a relatif name (ie the name of the key not the path)
* `comment`      - Set or print the comment
* `ls`           - List all the keys, fingerprint and permissions on the file system and agent
* `passphrase`   - Set, delete a passphrase
* `perm`         - Set the correct permission for the keys (ie 0600)
* `rm`           - Remove a private key from the agent

Permissions should be set to `0600`.
We control also them for public key as `ssh` will refuse to use them as identity input otherwise.
(ie in this case, ssh will lookup a private key in the agent)
EOF

}

list_command(){
  # Ssh dir
      KEYS=()
      for FILE in "$HOME"/.ssh/*; do
        TYPE=$(file -b "$FILE")
        if [[ $TYPE  =~ "key" ]]; then
          KEY_LINES=()
          # Print f template
          # template for key properties
          PRINTF_TEMPLATE_KEY_PROPS="%22s : %s"
          # Head
          KEY_LINES+=("$(printf "%-22s : %s" "$TYPE" "$FILE")")
          # Fingerprint
          # Valid options for fingerprint  hash algo (-E) options are: “md5” and “sha256”.
          FINGERPRINT=$(ssh-keygen -lf "$FILE")
          # shellcheck disable=SC2059
          KEY_LINES+=("$(printf "$PRINTF_TEMPLATE_KEY_PROPS" "Fingerprint" "$FINGERPRINT")")

          # Private Key Only
          if crypto::is_private_key "$FILE"; then

            # Loaded State
            IS_LOADED=$(ssh::is_key_in_agent "$FILE" "$FILE" && echo $? || echo $?)
            LOADED_STATE=""
            if [ "$IS_LOADED" == 0 ]; then
              LOADED_STATE="Loaded"
            else
              LOADED_STATE="Not loaded"
            fi
            # shellcheck disable=SC2059
            KEY_LINES+=("$(printf "$PRINTF_TEMPLATE_KEY_PROPS" "Agent" "$LOADED_STATE")")

            # Protection
            STATUS=$(crypto::is_protected_key "$FILE" && echo $? || echo $?)
            case $STATUS in
              "0")
                PROTECTION_STATE="Protected"
                ;;
              1)
                PROTECTION_STATE="$(string::set_color red "Not protected")"
                ;;
              *)
                PROTECTION_STATE="Unknown $STATUS"
                ;;
            esac
            # shellcheck disable=SC2059
            KEY_LINES+=("$(printf "$PRINTF_TEMPLATE_KEY_PROPS" "Protection" "$PROTECTION_STATE")")
          fi

          # Good permissions?
          PERM=$(stat -c "%a" "$FILE")
          if [ "$PERM" != "600" ]; then
            PERMISSION_STATE="$(string::set_color red "Bad ($PERM and not 0600)")"
          else
            PERMISSION_STATE="Good (0600)"
          fi
          # shellcheck disable=SC2059
          KEY_LINES+=("$(printf "$PRINTF_TEMPLATE_KEY_PROPS" "File Permission" "$PERMISSION_STATE")")

          KEYS+=("$(IFS=$'\n'; echo "${KEY_LINES[*]}")"$'\n')
        fi
      done
      echo
      echo "File System Keys"
      echo "----------------"
      echo
      if [ "${#KEYS[@]}" -ge 1 ]; then
        echo -e "$(array::join --sep $'\n' "${KEYS[@]}")" \
        | string::add_marge
      else
        echo "No file system keys found"
      fi
      echo
      # SSH_X_AGENT_RUN_STATE
      SSH_X_AGENT_RUN_STATE=$(ssh::agent_state)
      SSH_X_AGENT_RUN_STATE_NAME=$(ssh::agent_state_human)
      # Agent
      echo "Agent"
      echo "----------------"
      echo "Agent State: $SSH_X_AGENT_RUN_STATE_NAME"
      if [ "$SSH_X_AGENT_RUN_STATE" == 0 ]; then
        # Agent
        echo "Agent Keys":
        echo
        if OUTPUT=$(ssh-add -l); then
          # shellcheck disable=SC2001
          echo -e "Public Key Fingerprints of loaded Private Keys:\n$OUTPUT\n" | string::add_marge
          echo
        else
          echo "No agent keys found"
        fi
        # We should have an option here
  #      if OUTPUT=$(ssh-add -L); then
  #          # shellcheck disable=SC2001
  #          echo -e "Key Listing (as Public Keys):\n$OUTPUT\n" | string::add_marge
  #      else
  #          echo "No agent keys found"
  #      fi
      fi
      echo
}


remove_synopsis(){

  cat << 'EOF'
```bash
ssh-x key rm [--all|-a] [path...]
```

where `options and argument` are:

* `--all -a`  - Remove all keys
* `path`      - Path to one ore more key to remove

EOF

}

remove_command(){

  # Note: for now, we remove the key from the agent
  # but we could remove it from the known_hosts file with
  # ssh-keygen -R remote_host

  if [ $# -eq 0 ]; then
    doc::help remove_synopsis
    echo::err "No arguments supplied"
    return 1
  fi

  args=$(getopt -l "all" -o "a" -- "$@")
  # eval set to set the positional arguments back to $args
  eval set -- "$args"

  while [[ $# -gt 0 ]]
  do
     case "$1" in
      "--all"|"-a")
        # Remove ALL keys from the agent
        ssh-add -D
        shift;
        break;
      ;;
      --)
        # args
        shift
        ;;
      *)

        ssh-add -d "$1"
        shift
        ;;
      esac
  done

}


# Assign the first argument to a string
COMMAND=${1:-}
if [ "$COMMAND" = "" ]; then
    doc::help
    echo "A command is mandatory"
    error::exit 1
fi
# Help
if [[ "$COMMAND" =~ "-h"|"--help"|"help" ]]; then
  man sshx-key
  exit
fi
# Remove the first argument from the argument list
shift

# env
ENV=$(source ssh-x-env)
echo::debug "$ENV"
eval "$ENV"

case "$COMMAND" in
  "passphrase")
    ssh-x-key-passphrase "$@" || error::exit $?
    ;;
  "comment")
    comment_command "$@"
    ;;
  "list"|"ls")
    list_command
    ;;
  "permission"|"perm")
    chmod 0600 "$@"
    ;;
  "rm"|"remove")
    remove_command  "$@"
    ;;
  "add")
    ssh::add_key "$@"
    ;;
  "synopsis")
    synopsis;
    ;;
  *)
    doc::help
    echo::err  "Command $COMMAND is unknown"
    exit 1
esac
