#!/usr/bin/env bash
# Start an agent for the whole system (not one by session)
# and add keys if available

set -Eeuo pipefail
export PATH=${SSH_BASHLIB_LIBRARY_PATH}:$PATH
# shellcheck source=./bashlib-error.sh
source "bashlib-error.sh"
source bashlib-error.sh
error::set_trap
# shellcheck source=./bashlib-echo.sh
source "bashlib-echo.sh"
# shellcheck source=./bashlib-doc.sh
source "bashlib-doc.sh"
# shellcheck source=ssh-x-lib.sh
source ssh-x-lib.sh


synopsis(){

  cat << EOF
\`\`\`bash
$(basename "$0")
\`\`\`
EOF

}

# @description
#   This function will load keys that are:
#   * non-protected
#   * protected where the passphrase is defined by env variables
#
#   **How it works?**
#
#   The function will loop through the environment variables with the `SSH_X_KEY_PASSPHRASE` prefix.
#
#   When it finds an env such as `SSH_X_KEY_PASSPHRASE_MY_KEY`, the function will:
#	    * try to find a file at `~/.ssh/my_key`
#	    * add it with the value of `SSH_X_KEY_PASSPHRASE_MY_KEY` as passphrase
#
add_keys(){

  # add default non-protected keys from ~/.ssh
  ssh-add || echo::info "No unprotected keys in ~/.ssh to load"

	# Loop through the SSH_X_KEY_PASSPHRASE environment variables
	# and add the key to the agent
	# Example:
	# With the env `SSH_X_KEY_PASSPHRASE_MY_KEY` the script below will:
	# * try to find a file at `~/.ssh/my_key`
	# * add it with the value of `SSH_X_KEY_PASSPHRASE_MY_KEY` as passphrase
	#
	SSH_VAR_PREFIX='SSH_X_KEY_PASSPHRASE_'
	if ! SSH_X_KEY_VARIABLES=$(printenv | grep -oP "^$SSH_VAR_PREFIX\K[^=]+"); then
	  # No env found, grep returns 1
	  return
	fi
	for SSH_X_KEY_VARS in $SSH_X_KEY_VARIABLES
	do

	  KEY_FILENAME=$(echo "$SSH_X_KEY_VARS" | tr '[:upper:]' '[:lower:]')
    SSH_X_PASSPHRASE=$(eval "echo \$$SSH_VAR_PREFIX$SSH_X_KEY_VARS")
    export SSH_ASKPASS=ssh-x-askpass-env
    export SSH_X_TIMEOUT=5 # 5 second
    ssh::add_key "$KEY_FILENAME" "$SSH_X_PASSPHRASE"

	done

}

# @description
#    Start an agent and store the env in a file passed as argument
#    When starting an agent, this function will create an ENV file
#    The env file contains:
#    * the [SSH_AUTH_SOCK](https://man.archlinux.org/man/ssh.1.en#SSH_AUTH_SOCK)
#    * and SSH_AGENT_PID env values
#    It's a wrapper around `eval "$(ssh-agent -s)"`
#
# @arg $1 - The env file path (default to `$SSH_ENV`)
# @arg $2 - The socket file path (default to `$SSH_AUTH_SOCK`)
# @example
#   agent_start
#   # after the agent start, you would get
#   SSH_AUTH_SOCK=/tmp/ssh-XXXXXXVv4IgB/agent.17882; export SSH_AUTH_SOCK;
#   SSH_AGENT_PID=17883; export SSH_AGENT_PID;
#   echo Agent pid 17883;
#
agent_start () {
	local ENV="${1:-SSH_X_AGENT_ENV}"
	local SOCK="${2:-$SSH_AUTH_SOCK}"
  echo::info "Starting the ssh-agent with"
  echo::info "  * env file  at $ENV"
  echo::info "  * sock file at $SSH_AUTH_SOCK"
  echo::info "  * a default lifetime of $SSH_X_LIFE"
  (umask 077; ssh-agent -a "$SOCK" -t "$SSH_X_LIFE" >| "$ENV")
}

# Doc
if [ "${1:-}" == "synopsis" ]; then
  synopsis
  exit
fi

# Load the env
eval "$(source ssh-x-env)"

# Load the env if available
ssh::agent_load_env "$SSH_X_AGENT_ENV"

# Get the state
SSH_X_AGENT_RUN_STATE=$(ssh::agent_state)
if [ ! "$SSH_AUTH_SOCK" ] || [ "$SSH_X_AGENT_RUN_STATE" = 2 ]; then
  echo::info "Agent not started"
  # The sock may be a symlink, so -e check that
  # -f check only if it's a regular file
  if [ -e "$SSH_AUTH_SOCK" ]; then
    echo::info "Deleting Sock file $SSH_AUTH_SOCK"
    rm "$SSH_AUTH_SOCK"
  fi
  echo::info "Starting Agent"
  agent_start "$SSH_X_AGENT_ENV" "$SSH_AUTH_SOCK"
  add_keys
elif [ "$SSH_AUTH_SOCK" ] && [ "$SSH_X_AGENT_RUN_STATE" = 1 ]; then
  echo::info "Agent started but empty, trying to add keys"
  add_keys
fi

# Output the export script
cat "$SSH_X_AGENT_ENV"
