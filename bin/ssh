#!/bin/bash
# A ssh wrapper to load private key

# Ref
# https://unix.stackexchange.com/questions/514008/how-to-pass-to-ssh-the-key-stored-in-a-shell-environment-variable
#
# Bash wrapper for OpenSSH CLI tools (ssh, scp, sftp, or any that accept
# the `-i /path/to/keyfile` option) that allows for passing an SSH private
# key as the first parameter rather than via a persistent identity file.
# This is something that is not possible with ssh tools by default.
#
# This command is useful when storing the key in an environment variable
# that is set in some secure way, such as set via secrets mastered in the
# AWS Parameter Store, or as the result another command in a subshell.
#
# The "OPENSSH PRIVATE KEY" lines at the beginning and end of the passed
# key string will be added if they are not on already present.
#
# Usage: with-ssh-key {ssh | scp | sftp} KEY ADDITIONAL_ARGS...
#
# Examples:
#   key="b3blbnnzaC1rZXktdjEAAAAABG5vbmUAAAA[etc...]"
#   with-ssh-key "$key" ssh myserver echo Hello-from-myserver
#   with-ssh-key "$key" scp myserver:file.txt ./
#   echo get file.txt | with-ssh-key "$key" sftp myserver
#
# A note regarding zsh: this wrapper is not necessary in zsh because zsh
# has the extremely convenient `=(cmd)` syntax which will create a real
# on-disk tempfile and clean it up immediately after the calling command
# exits. Thus you can easily do something like this in zsh to accomplish
# the same effect as this wrapper:
#
#   ssh -i =(echo "$key") ...
#
# Or, if you need to add the header/footer lines:
#
#   ssh -i =(echo "-----BEGIN OPENSSH PRIVATE KEY-----\n$(echo "$key")\n-----END OPENSSH PRIVATE KEY-----")
#set -euo pipefail
#key="$1"; shift
#cmd="$1"; shift
#tempkeyfile=$(mktemp)
#chmod 600 "$tempkeyfile" # ensure file is locked down
#trap "rm \"$tempkeyfile\"" 0 2 3 15 # ensure tempfile cleanup in event of various signals
#[[ $key =~ "BEGIN OPENSSH PRIVATE KEY" ]] || echo "-----BEGIN OPENSSH PRIVATE KEY-----" >> $tempkeyfile
#echo "$key" >> $tempkeyfile
#[[ $key =~ "END OPENSSH PRIVATE KEY" ]] || echo "-----END OPENSSH PRIVATE KEY-----" >> $tempkeyfile
#$cmd -i "$tempkeyfile" "$@"

SSH_PATH=/usr/bin/ssh
# To Debug, just uncomment the below line to see the args called
echo "Ssh Command: GIT_PROTOCOL=$GIT_PROTOCOL ssh $*" > /dev/tty
# Example:
# * SSH Git Fetch or Pull
# ssh -o SendEnv=GIT_PROTOCOL git@github.com git-upload-pack 'gerardnico/ssh-x.git'
# * SSH Git Push
# ssh git@github.com git-receive-pack 'gerardnico/ssh-x.git'


# We got the type of option (ie with or without value) with `ssh --help`
# ssh has no long option,
# the `:` after each letter is to say that a value is expected after the option
args=$(getopt --options "46AaCfGgKkMNnqsTtVvXxYyB:b:c:D:E:e:F:I:i:J:L:l:m:O:o:p:Q:R:S:W:w:" -- "$@")
# eval set to set the positional arguments back to $args
eval set -- "$args"
DESTINATION=""
while [[ $# -gt 0 ]]
do
   case "$1" in
    --)
      shift;
      DESTINATION=$1
      break;
      ;;
    *)
      shift;
      ;;
   esac
done

echo "Destination: $DESTINATION" > /dev/tty

KEY=$($SSH_PATH -T -G "$DESTINATION" | grep identity | awk '{ print $2 }')
echo "Key for destination ($DESTINATION): $KEY" > /dev/tty

$SSH_PATH "$@"