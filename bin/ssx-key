#!/bin/bash

set -Eeuo pipefail
source bashlib-echo.sh
source bashlib-doc.sh
source bashlib-crypto.sh
source bashlib-ssh.sh
source bashlib-command.sh
source bashlib-error.sh
source bashlib-array.sh
error::set_trap


synopsis_comment(){

  cat << 'EOF'

Usage:

```bash
sshx key comment path "New comment"
```

where:

* `path`         - The path to the key
* `New Comment`  - A new comment
EOF

}

comment_command(){
  # Change the comment
  if [ $# -ne 2 ]; then
     synopsis_comment
     echo::err "A key path and a comment is mandatory"
     error::exit 1
  fi
  FILE=${1}
  if [ ! -f "$FILE" ]; then
    echo::err "The key file ($FILE) does not exist"
    error::exit 1
  fi
  ssh-keygen -c -f "$FILE" -C "$2"
}

# The synopsis function is required by the doc::usage
synopsis(){

  cat << 'EOF'
```bash
sshx key command options
```

where `command` can be:

* `comment`      - Set or print the comment
* `passphrase`   - Set, delete a passphrase
* `perm`         - Set the correct permission for the keys (ie 0600)
* `ls`           - List all the keys, fingerprint and permissions on the file system and agent (along with )
* `rm`           - Remove a private key from the agent
* `add`          - Add a private key from the agent

Permissions should be set to `0600`.
We control also them for public key as `ssh` will refuse to use them as identity input otherwise.
(ie in this case, ssh will lookup a private key in the agent)
EOF

}


list_command(){
  # Ssh dir
      KEYS=()
      for FILE in "$HOME"/.ssh/*; do
        TYPE=$(file -b "$FILE")
        if [[ $TYPE  =~ "key" ]]; then
          STATUS_MESSAGES=()
          if crypto::is_private_key "$FILE"; then

            IS_LOADED=$(ssh::is_key_in_agent "$FILE" "$FILE" && echo $? || echo $?)
            if [ "$IS_LOADED" == 0 ]; then
              STATUS_MESSAGES+=("Loaded in Agent")
            else
              STATUS_MESSAGES+=("Not loaded in Agent")
            fi

            STATUS=$(crypto::is_protected_key "$FILE" && echo $? || echo $?)
            case $STATUS in
              "0")
                STATUS_MESSAGES+=("Protected")
                ;;
              1)
                STATUS_MESSAGES+=("$(string::set_color red "Not protected")")
                ;;
              *)
                STATUS_MESSAGES+=("Unknown $STATUS")
                ;;
            esac
          fi
          # Good permissions?
          PERM=$(stat -c "%a" "$FILE")
          if [ "$PERM" != "600" ]; then
            STATUS_MESSAGES+=("$(string::set_color red "Bad Permission ($PERM and not 0600)")")
          fi
          # Valid options for fingerprint  hash algo (-E) options are: “md5” and “sha256”.
          FINGERPRINT=$(ssh-keygen -lf "$FILE")
          STATUS_MESSAGE=""
          if [ ${#STATUS_MESSAGES[@]} -ne 0 ]; then
            STATUS_MESSAGE="($(IFS=,; echo "${STATUS_MESSAGES[*]}"))"
          fi
          KEYS+=("$(printf '%-22s : %s %s\n%-22s : %s' "$TYPE" "$FILE" "${STATUS_MESSAGE}" "      Fingerprint" "$FINGERPRINT")"$'\n')
        fi
      done
      echo
      echo "File System Keys"
      echo
      if [ "${#KEYS[@]}" -ge 1 ]; then
        echo -e "$(array::join --sep $'\n' "${KEYS[@]}")" \
        | string::add_marge
      else
        echo "No file system keys found"
      fi
      echo
      # Agent
      echo "Agent Keys"
      echo
      if OUTPUT=$(ssh-add -l); then
        # shellcheck disable=SC2001
        echo -e "Keys Fingerprint:\n$OUTPUT\n" | string::add_marge
        echo
      else
        echo "No agent keys found"
      fi
      if OUTPUT=$(ssh-add -L); then
          # shellcheck disable=SC2001
          echo -e "Public Keys:\n$OUTPUT\n" | string::add_marge
      else
          echo "No agent keys found"
      fi
      echo
}


remove_synopsis(){

  cat << 'EOF'
```bash
sshx key rm [--all|-a] [path...]
```

where `options and argument` are:

* `--all -a`  - Remove all keys
* `path`      - Path to one ore more key to remove

EOF

}

remove_command(){

  if [ $# -eq 0 ]; then
    doc::help remove_synopsis
    echo::err "No arguments supplied"
    return 1
  fi

  args=$(getopt -l "all" -o "a" -- "$@")
  # eval set to set the positional arguments back to $args
  eval set -- "$args"

  while [[ $# -gt 0 ]]
  do
     case "$1" in
      "--all"|"-a")
        ssh-add -D
        shift;
        break;
      ;;
      --)
        # args
        shift
        ;;
      *)
        ssh-add -d "$1"
        shift
        ;;
      esac
  done

}


# Assign the first argument to a string
COMMAND=${1:-}
if [ "$COMMAND" = "" ]; then
    doc::help
    echo "A command is mandatory"
    error::exit 1
fi
# Help
if [[ "$COMMAND" =~ "-h"|"--help"|"help" ]]; then
  man sshx-key
  exit
fi
# Remove the first argument from the argument list
shift


case "$COMMAND" in
  "passphrase")
    sshx-key-passphrase "$@" || error::exit $?
    ;;
  "comment")
    comment_command "$@"
    ;;
  "list"|"ls")
    list_command
    ;;
  "permission"|"perm")
    chmod 0600 "$@"
    ;;
  "rm"|"remove")
    remove_command  "$@"
    ;;
  "add")
    # ssh-add -t 300 "$@"
    ssh-add "$@"
    ;;
  *)
    echo::err  "Command $COMMAND is unknown"
    exit 1
esac
