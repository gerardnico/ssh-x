#!/usr/bin/env bash

set -Eeuo pipefail
# shellcheck source=./bashlib-error.sh
source "${BASHLIB_LIBRARY_PATH:-}${BASHLIB_LIBRARY_PATH:+/}bashlib-error.sh"
source bashlib-error.sh
error::set_trap
# shellcheck source=./bashlib-echo.sh
source "${BASHLIB_LIBRARY_PATH:-}${BASHLIB_LIBRARY_PATH:+/}bashlib-echo.sh"
# shellcheck source=./bashlib-doc.sh
source "${BASHLIB_LIBRARY_PATH:-}${BASHLIB_LIBRARY_PATH:+/}bashlib-doc.sh"
# shellcheck source=./bashlib-ssh.sh
source "${BASHLIB_LIBRARY_PATH:-}${BASHLIB_LIBRARY_PATH:+/}bashlib-ssh.sh"


synopsis(){

  cat << EOF
\`\`\`bash
$(basename $0)
\`\`\`
EOF

}

# @description
#   This function will load keys that are:
#   * non-protected
#   * protected where the passphrase is defined by env variables
#
#   **How it works?**
#
#   The function will loop through the environment variables with the `SSH_KEY_PASSPHRASE` prefix.
#
#   When it finds an env such as `SSH_X_KEY_PASSPHRASE_MY_KEY`, the function will:
#	    * try to find a file at `~/.ssh/my_key`
#	    * add it with the value of `SSH_X_KEY_PASSPHRASE_MY_KEY` as passphrase
#
add_keys(){

  # add default non-protected keys from ~/.ssh
  ssh-add || echo::info "No non-protected keys found in ~/.ssh and added to agent"

	# Loop through the SSH_X_KEY_PASSPHRASE environment variables
	# and add the key to the agent
	# Example:
	# With the env `SSH_X_KEY_PASSPHRASE_MY_KEY` the script below will:
	# * try to find a file at `~/.ssh/my_key`
	# * add it with the value of `SSH_X_KEY_PASSPHRASE_MY_KEY` as passphrase
	#
	SSH_VAR_PREFIX='SSH_X_KEY_PASSPHRASE_'
	for SSH_X_KEY_VARS in $(printenv | grep -oP "^$SSH_VAR_PREFIX\K[^=]+")
	do
	  KEY_FILENAME=$(echo "$SSH_X_KEY_VARS" | tr '[:upper:]' '[:lower:]')
	  KEY_VARIABLE_NAME="$SSH_VAR_PREFIX$SSH_X_KEY_VARS"
	  KEY_FILE_PATH="${SSH_X_KEY_HOME}/$KEY_FILENAME"
	  echo::info "The SSH env variable $KEY_VARIABLE_NAME was found"
	  if [ ! -f "$KEY_FILE_PATH" ]; then
	    echo::info "The env variable $KEY_VARIABLE_NAME designs a key file ($KEY_FILE_PATH) that does not exist" >&2
      continue
	  fi
    echo::info "Trying to add the key $KEY_FILENAME to the SSH agent"
    # The instruction is in the man page. SSH_ASKPASS needs a path to an executable
    # that emits the secret to stdout.
    # See doc: https://man.archlinux.org/man/ssh.1.en#SSH_ASKPASS
    SSH_X_PASSPHRASE=$(eval "echo \$$SSH_VAR_PREFIX$SSH_X_KEY_VARS")
    TIMEOUT=5
    echo::info "  - Executing ssh-add (if the passphrase is incorrect, the execution will freeze for ${TIMEOUT} sec)"
    # freeze due to SSH_ASKPASS_REQUIRE=force otherwise it will ask it at the terminal
    if ! RESULT=$(timeout $TIMEOUT bash -c "DISPLAY=:0 SSH_ASKPASS_REQUIRE=force SSH_ASKPASS=ssh-x-askpass-env SSH_X_PASSPHRASE=$SSH_X_PASSPHRASE ssh-add -t $SSH_X_LIFE $KEY_FILE_PATH" 2>&1); then
      echo "Bad Passphrase for $KEY_FILENAME"
      continue
    fi
    echo::info "  - $RESULT" # should be `Identity added:xxx`
	done

}

# @description
#    Start an agent and store the env in a file passed as argument
#    When starting an agent, this function will create an ENV file
#    The env file contains:
#    * the [SSH_AUTH_SOCK](https://man.archlinux.org/man/ssh.1.en#SSH_AUTH_SOCK)
#    * and SSH_AGENT_PID env values
#    It's a wrapper around `eval "$(ssh-agent -s)"`
#
# @arg $1 - The env file path (default to `$SSH_ENV`)
# @arg $2 - The socket file path (default to `$SSH_AUTH_SOCK`)
# @example
#   agent_start
#   # after the agent start, you would get
#   SSH_AUTH_SOCK=/tmp/ssh-XXXXXXVv4IgB/agent.17882; export SSH_AUTH_SOCK;
#   SSH_AGENT_PID=17883; export SSH_AGENT_PID;
#   echo Agent pid 17883;
#
agent_start () {
	local ENV="${1:-SSH_X_AGENT_ENV}"
	local SOCK="${2:-$SSH_AUTH_SOCK}"
  echo::info "Starting the ssh-agent with"
  echo::info "  * env file  at $ENV"
  echo::info "  * sock file at $SSH_AUTH_SOCK"
  echo::info "  * a default lifetime of $SSH_X_LIFE"
  (umask 077; ssh-agent -a "$SOCK" -t "$SSH_X_LIFE" >| "$ENV")
}

# Doc
if [ "${1:-}" == "synopsis" ]; then
  synopsis
  exit
fi

# Load the env
eval "$(ssh-x-env)"

# Load the env if available
ssh::agent_load_env "$SSH_X_AGENT_ENV"

# Get the state
SSH_X_AGENT_RUN_STATE=$(ssh::agent_state)
if [ ! "$SSH_AUTH_SOCK" ] || [ "$SSH_X_AGENT_RUN_STATE" = 2 ]; then
  echo::info "Agent not started"
  # The sock may be a symlink, so -e check that
  # -f check only if it's a regular file
  if [ -e "$SSH_AUTH_SOCK" ]; then
    echo::info "Deleting Sock file $SSH_AUTH_SOCK"
    rm "$SSH_AUTH_SOCK"
  fi
  echo::info "Starting Agent"
  agent_start "$SSH_X_AGENT_ENV" "$SSH_AUTH_SOCK"
  #add_keys
elif [ "$SSH_AUTH_SOCK" ] && [ "$SSH_X_AGENT_RUN_STATE" = 1 ]; then
  echo::info "Agent started but empty, trying to add keys"
  #add_keys
fi

# Output the export script
cat "$SSH_X_AGENT_ENV"
